#!/usr/bin/env node
/**
 * Generate coverage reports from E2E and unit tests
 *
 * - E2E tests (Playwright): Output raw V8 coverage to .coverage-data/
 * - Unit tests (Vitest + MCR): Output raw V8 coverage to coverage-unit/raw/
 *
 * Generates three reports:
 * - coverage-e2e/: E2E-only HTML report
 * - coverage/: Combined (E2E + Unit) HTML report
 * - coverage-unit/: Unit-only (already generated by vitest)
 */

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import MCR from "monocart-coverage-reports";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.join(__dirname, "..");

/**
 * Filter V8 coverage data to only include JS source files
 */
function filterV8Coverage(data) {
  if (!Array.isArray(data)) return data;

  return data.filter((entry) => {
    const url = entry.url || "";
    // Skip if no URL
    if (!url) return false;
    // Only include JS files
    if (!url.endsWith(".js")) return false;
    // Skip node_modules and test files
    if (url.includes("node_modules")) return false;
    if (url.includes("tests/")) return false;
    // Must be from our extension (chrome-extension:// URLs have main.js)
    return url.includes("main.js") || url.includes("/src/");
  });
}

/**
 * Load E2E coverage files from .coverage-data directory
 */
function loadE2ECoverageFiles(e2eCoverageDir) {
  const coverageData = [];
  if (!fs.existsSync(e2eCoverageDir)) return coverageData;

  const files = fs
    .readdirSync(e2eCoverageDir)
    .filter((f) => f.endsWith(".json"));

  for (const file of files) {
    const filePath = path.join(e2eCoverageDir, file);
    try {
      const rawData = JSON.parse(fs.readFileSync(filePath, "utf-8"));
      const filteredData = filterV8Coverage(rawData);
      if (filteredData.length > 0) {
        coverageData.push(filteredData);
      }
    } catch (_err) {
      console.warn(`Warning: Could not parse E2E coverage ${file}`);
    }
  }
  return coverageData;
}

/**
 * Create MCR source filter function
 */
function createSourceFilter() {
  return (sourcePath) => {
    if (sourcePath.includes("node_modules")) return false;
    if (sourcePath.includes("tests/")) return false;
    return (
      sourcePath.includes("/src/") ||
      sourcePath.startsWith("src/") ||
      sourcePath.includes("main.js")
    );
  };
}

/**
 * Write coverage summary JSON
 */
function writeSummary(outputDir, results, sources) {
  const summary = {
    bytes: results.summary?.bytes?.pct || 0,
    lines: results.summary?.lines?.pct || 0,
    functions: results.summary?.functions?.pct || 0,
    statements: results.summary?.statements?.pct || 0,
    branches: results.summary?.branches?.pct || 0,
    ...sources,
    timestamp: new Date().toISOString(),
  };

  fs.writeFileSync(
    path.join(outputDir, "coverage-summary.json"),
    JSON.stringify(summary, null, 2)
  );

  return summary;
}

/**
 * Print coverage summary to console
 */
function printSummary(name, summary, outputDir) {
  console.log(`\n${"=".repeat(50)}`);
  console.log(`${name}:`);
  console.log("=".repeat(50));
  console.log(`  Bytes:      ${Number(summary.bytes).toFixed(2)}%`);
  console.log(`  Lines:      ${Number(summary.lines).toFixed(2)}%`);
  console.log(`  Functions:  ${Number(summary.functions).toFixed(2)}%`);
  console.log(`  Branches:   ${Number(summary.branches).toFixed(2)}%`);
  console.log(`  Report:     ${outputDir}/index.html`);
}

/**
 * Generate E2E-only coverage report
 */
async function generateE2EReport(e2eCoverageData) {
  const outputDir = path.join(rootDir, "coverage-e2e");
  if (fs.existsSync(outputDir)) {
    fs.rmSync(outputDir, { recursive: true });
  }
  fs.mkdirSync(outputDir, { recursive: true });

  const mcr = new MCR({
    name: "E2E Coverage Report",
    outputDir: outputDir,
    reports: ["v8", "html", "console-summary"],
    sourceFilter: createSourceFilter(),
  });

  for (const data of e2eCoverageData) {
    await mcr.add(data);
  }

  console.log(
    `\nGenerating E2E-only report (${e2eCoverageData.length} files)...`
  );
  const results = await mcr.generate();
  const summary = writeSummary(outputDir, results, {
    hasE2E: true,
    hasUnit: false,
  });
  printSummary("E2E Coverage Summary", summary, outputDir);

  return summary;
}

/**
 * Generate combined coverage report
 */
async function generateCombinedReport(e2eCoverageData, unitRawDir, hasUnit) {
  const outputDir = path.join(rootDir, "coverage");
  if (fs.existsSync(outputDir)) {
    fs.rmSync(outputDir, { recursive: true });
  }
  fs.mkdirSync(outputDir, { recursive: true });

  const mcrConfig = {
    name: "Combined Coverage Report (Unit + E2E)",
    outputDir: outputDir,
    reports: ["v8", "html", "console-summary"],
    sourceFilter: createSourceFilter(),
  };

  // Use inputDir for unit coverage if available
  if (hasUnit) {
    mcrConfig.inputDir = unitRawDir;
  }

  const mcr = new MCR(mcrConfig);

  // Add E2E coverage
  for (const data of e2eCoverageData) {
    await mcr.add(data);
  }

  console.log("\nGenerating combined report...");
  if (hasUnit) console.log("  - Unit coverage from:", unitRawDir);
  console.log(`  - E2E coverage: ${e2eCoverageData.length} files`);

  const results = await mcr.generate();
  const summary = writeSummary(outputDir, results, {
    hasE2E: e2eCoverageData.length > 0,
    hasUnit: hasUnit,
  });
  printSummary("Combined Coverage Summary", summary, outputDir);

  return summary;
}

async function generateCoverage() {
  console.log("Generating coverage reports...\n");

  // Check what coverage sources are available
  const e2eCoverageDir = path.join(rootDir, ".coverage-data");
  const unitRawDir = path.join(rootDir, "coverage-unit", "raw");

  const hasUnitCoverage =
    fs.existsSync(unitRawDir) &&
    fs.readdirSync(unitRawDir).some((f) => f.endsWith(".json"));

  // Load E2E coverage data (we'll use it for both E2E-only and combined reports)
  const e2eCoverageData = loadE2ECoverageFiles(e2eCoverageDir);
  const hasE2ECoverage = e2eCoverageData.length > 0;

  if (!hasE2ECoverage && !hasUnitCoverage) {
    console.log("No coverage data found. Run tests first:");
    console.log("  pnpm run coverage:all");
    process.exit(1);
  }

  console.log("Coverage sources found:");
  if (hasUnitCoverage) console.log("  - Unit tests (coverage-unit/raw/)");
  if (hasE2ECoverage)
    console.log(
      `  - E2E tests (${e2eCoverageData.length} files in .coverage-data/)`
    );

  let combinedSummary;

  // Generate E2E-only report if we have E2E coverage
  if (hasE2ECoverage) {
    await generateE2EReport(e2eCoverageData);
  }

  // Generate combined report if we have both, or just one source
  combinedSummary = await generateCombinedReport(
    e2eCoverageData,
    unitRawDir,
    hasUnitCoverage
  );

  // Clean up .coverage-data after generating reports
  if (fs.existsSync(e2eCoverageDir)) {
    fs.rmSync(e2eCoverageDir, { recursive: true });
  }

  // Check minimum coverage threshold (if set via env)
  const minCoverage = Number.parseFloat(process.env.MIN_COVERAGE || "0");
  if (minCoverage > 0 && combinedSummary.bytes < minCoverage) {
    console.error(
      `\nCoverage (${combinedSummary.bytes.toFixed(1)}%) is below minimum threshold (${minCoverage}%)!`
    );
    process.exitCode = 1;
  }

  console.log(`\n${"=".repeat(50)}`);
  console.log("All reports generated successfully!");
  console.log("=".repeat(50));
}

generateCoverage().catch((err) => {
  console.error("Error generating coverage:", err);
  process.exit(1);
});
